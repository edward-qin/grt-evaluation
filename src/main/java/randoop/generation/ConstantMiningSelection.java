package randoop.generation;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import randoop.main.GenInputsAbstract;
import randoop.sequence.ExecutableSequence;
import randoop.sequence.Sequence;
import randoop.util.Randomness;
import randoop.util.SimpleList;

/**
 * Implements the Constant Mining component, as described by the paper "GRT: Program-Analysis-Guided
 * Random Testing" by Ma et. al (appears in ASE 2015):
 * https://people.kth.se/~artho/papers/lei-ase2015.pdf .
 */
public class ConstantMiningSelection implements InputSequenceSelector {
  /**
   * Map of extracted literal sequences to their static weights. These weights are never changed
   * once initialized.
   */
  private final Map<Sequence, Double> literalWeightMap = new HashMap<>();

  /**
   * Initialize Constant Mining selection by computing weights for literals that appear in classes
   * under test.
   *
   * @param componentManager reference to component generator from {@link ForwardGenerator} used for
   *     getting the frequency of a literal
   * @param numClasses number of classes under tests
   * @param literalTermFrequencies a map from a literal to the number of times it appears in any
   *     class under test. If literalTermFrequencies is null, we simply don't compute any weights to
   *     put in literalWeightMap and every sequence will end up using its default weight computed
   *     with {@code sequence.getWeight();}.
   */
  public ConstantMiningSelection(
      ComponentManager componentManager,
      int numClasses,
      Map<Sequence, Integer> literalTermFrequencies) {
    Map<Sequence, Integer> seqDocumentFrequencies = componentManager.getSeqDocumentFrequency();

    if (GenInputsAbstract.constant_mining_logging) {
      System.out.println("Literal term frequencies: ");
      System.out.println(literalTermFrequencies);
      System.out.println("Documenter term frequencies: ");
      System.out.println(seqDocumentFrequencies);
    }

    // We iterate through all literals that were found by the ClassLiteralExtractor.
    for (Sequence sequence : seqDocumentFrequencies.keySet()) {
      Integer documentFrequency = seqDocumentFrequencies.get(sequence);
      Integer termFrequency = literalTermFrequencies.get(sequence);

      // Compute the term frequency-inverse document frequency based on GRT's formula for
      // Constant Mining.
      double tfIdf =
          termFrequency * Math.log((numClasses + 1.0) / ((numClasses + 1.0) - documentFrequency));
      literalWeightMap.put(sequence, tfIdf);
    }
  }

  /**
   * Select a sequence from the candidate list. The candidate list contains various input sequences
   * that produce a specific type. The {@code literalWeightMap} is concerned only with input
   * sequences that are literals extracted from the classes under test. Other input sequences that
   * are generated by Randoop throughout the test generation process will not have a corresponding
   * weight in the literalWeightMap; instead, their default weight value is used, obtained by {@code
   * seq.getWeight()}.
   *
   * @param candidates sequences to choose from
   * @return the chosen sequence
   */
  @Override
  public Sequence selectInputSequence(SimpleList<Sequence> candidates) {
    if (GenInputsAbstract.constant_mining_logging) {
      outputCandidateWeights(candidates);
    }
    return Randomness.randomMemberWeighted(candidates, literalWeightMap);
  }

  /**
   * For debugging purposes, output the weights of the candidate list of input sequences.
   *
   * @param candidates list of input sequences
   */
  private void outputCandidateWeights(SimpleList<Sequence> candidates) {
    for (int i = 0; i < candidates.size(); i++) {
      Sequence sequence = candidates.get(i);
      Double sequenceWeight = literalWeightMap.get(sequence);
      if (sequenceWeight == null) {
        System.out.println("Using default weight " + sequence + " " + sequence.getWeight());
      } else {
        System.out.println("Using computed weight " + sequence + " " + sequenceWeight);
      }
    }
    System.out.println("------------");
  }

  /**
   * Unused by this class.
   *
   * @param inputSequences the sequences that were chosen as the input to the method under test for
   *     creating {@code eSeq} which is a new and unique sequence
   * @param eSeq the recently executed sequence which is new and unique
   */
  @Override
  public void createdExecutableSequenceFromInputs(
      List<Sequence> inputSequences, ExecutableSequence eSeq) {}
}
